(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{440:function(a,e,t){"use strict";t.r(e);var s=t(5),l=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"fp101x-week-2-types-and-classes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fp101x-week-2-types-and-classes"}},[a._v("#")]),a._v(" FP101x - week 2 Types and Classes")]),a._v(" "),e("h3",{attrs:{id:"type-error"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-error"}},[a._v("#")]),a._v(" Type Error")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("> 1+ False\nError\n")])])]),e("h3",{attrs:{id:"type-in-haskell"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-in-haskell"}},[a._v("#")]),a._v(" Type in Haskell")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("(expression)e :: (type)t")])])]),a._v(" "),e("h3",{attrs:{id:"type-in-ghci"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-in-ghci"}},[a._v("#")]),a._v(" :type in GHCi")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("> not False\nTrue\n")])])]),e("ul",[e("li",[a._v("calculates the type of an expression")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("> :type not False\nnot False :: Bool\n")])])]),e("h3",{attrs:{id:"basic-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#basic-types"}},[a._v("#")]),a._v(" Basic Types")]),a._v(" "),e("ul",[e("li",[a._v("Bool")]),a._v(" "),e("li",[a._v("Char")]),a._v(" "),e("li",[a._v("String")]),a._v(" "),e("li",[a._v("Int")]),a._v(" "),e("li",[a._v("Integer")]),a._v(" "),e("li",[a._v("Float")])]),a._v(" "),e("h3",{attrs:{id:"list-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list-types"}},[a._v("#")]),a._v(" List Types")]),a._v(" "),e("ul",[e("li",[a._v("sequence of value of the same type")]),a._v(" "),e("li",[a._v("[False, Trye, False] :: [Bool]")]),a._v(" "),e("li",[a._v("[‘a’, ‘b’, ‘c’ ] :: [Char]")]),a._v(" "),e("li",[a._v("[[‘a’], [‘b’, ‘c’]] :: [‘Char’]")])]),a._v(" "),e("h3",{attrs:{id:"tuple-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tuple-types"}},[a._v("#")]),a._v(" Tuple Types")]),a._v(" "),e("ul",[e("li",[a._v("A tuple is a sequence of values of different types")]),a._v(" "),e("li",[a._v("(False, Ture) :: (Bool, Bool)")]),a._v(" "),e("li",[a._v("(False, ‘a’, True) :: (Bool, Char, Bool)")])]),a._v(" "),e("h3",{attrs:{id:"function-types"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function-types"}},[a._v("#")]),a._v(" Function Types")]),a._v(" "),e("ul",[e("li",[a._v("not :: Bool -> Bool")]),a._v(" "),e("li",[a._v("isDigit :: Char -> Bool\n— 0, 1")]),a._v(" "),e("li",[a._v("argument and resist types are unrestricted")])]),a._v(" "),e("h3",{attrs:{id:"curried-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#curried-functions"}},[a._v("#")]),a._v(" Curried Functions")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("functions as results")])]),a._v(" "),e("li",[e("p",[a._v("add’      :: Int -> (Int -> Int)\nadd’ x y = x+y")])]),a._v(" "),e("li",[e("p",[a._v("more flexible then functions on tuples")])]),a._v(" "),e("li",[e("p",[a._v("associate to the left\nmult x y z\nmeans (((mult x) y) z)")])])]),a._v(" "),e("h3",{attrs:{id:"polymorphic-fuctions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#polymorphic-fuctions"}},[a._v("#")]),a._v(" Polymorphic Fuctions")]),a._v(" "),e("ul",[e("li",[a._v("a function is called polymorphic (“of many forms”) if its type contains one or more type variables.")]),a._v(" "),e("li",[a._v("length :: [a] -> Int")])]),a._v(" "),e("p",[a._v("ex )")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("> length [False, True]\n2\n> length [1,2,3,4]\n4\n")])])]),e("ul",[e("li",[a._v("fst :: (a,b) -> a")]),a._v(" "),e("li",[a._v("head :: [a] -> a")]),a._v(" "),e("li",[a._v("take :: Int -> [a] -> [a]")]),a._v(" "),e("li",[a._v("zip :: [a] -> [b] -> [(a,b)]")]),a._v(" "),e("li",[a._v("id :: a -> a")])]),a._v(" "),e("h3",{attrs:{id:"overloaded-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#overloaded-functions"}},[a._v("#")]),a._v(" Overloaded Functions")]),a._v(" "),e("ul",[e("li",[a._v("a polymorphic function is called overloaded of its type contains one or more class contains")]),a._v(" "),e("li",[a._v("sum :: Num a => [a] -> a")])]),a._v(" "),e("p",[a._v("ex)")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("> sum [1,2,3]\n6\n> sum [‘a’,’b’,’c’]\nERROR\n")])])]),e("h3",{attrs:{id:"haskell-has-a-number-of-type-classes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#haskell-has-a-number-of-type-classes"}},[a._v("#")]),a._v(" Haskell has a number of type classes")]),a._v(" "),e("ul",[e("li",[a._v("Num : Numeric types")]),a._v(" "),e("li",[a._v("Eq : Equality types")]),a._v(" "),e("li",[a._v("Ord : Ordered types")])]),a._v(" "),e("p",[a._v("ex )")]),a._v(" "),e("ul",[e("li",[a._v("(+) :: Num a => a -> a -> a")]),a._v(" "),e("li",[a._v("(==) :: Eq a => a -> a -> Bool")]),a._v(" "),e("li",[a._v("(<) :: Ord a => a -> a -> Bool")])])])}),[],!1,null,null,null);e.default=l.exports}}]);