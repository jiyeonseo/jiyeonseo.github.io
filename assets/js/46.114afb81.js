(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{439:function(e,s,a){"use strict";a.r(s);var t=a(5),n=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"fp101x-week-3-defining-functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fp101x-week-3-defining-functions"}},[e._v("#")]),e._v(" FP101x - week 3 Defining Functions")]),e._v(" "),s("h3",{attrs:{id:"conditional-expressions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conditional-expressions"}},[e._v("#")]),e._v(" Conditional Expressions")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("abs :: Int -> Int")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("abs n = if n >= 0 then n else -n")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("signum :: Int -> Int")])])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("signum n = if n < 0 then -1 else\n                    if n == 0 then 0 else 1\n")])])]),s("h3",{attrs:{id:"guarded-equations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#guarded-equations"}},[e._v("#")]),e._v(" Guarded Equations")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" abs n | n >= 0     = n\n          | otherwise = -n\n\n signum n | n < 0 = -1\n                    | n == 0 =0\n                    | otherwise = 1\n")])])]),s("h3",{attrs:{id:"pattern-matching"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pattern-matching"}},[e._v("#")]),e._v(" Pattern Matching")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("not :: Bool -> Bool")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("not False = True")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("not True = False")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("(&&) :: Bool -> Bool -> Bool")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("True && True = True")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("True && False = False")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("False && True = False")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("False && False = False")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("True && True = True")])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("_ && _ = False")])])])]),e._v(" "),s("p",[e._v("so..")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("True && b = b")])]),e._v(" "),s("li",[s("code",[e._v("False && _ = False")])])]),e._v(" "),s("h3",{attrs:{id:"list-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list-pattern"}},[e._v("#")]),e._v(" List Pattern")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("[1,2,3,4] means 1:(2:(3:(4:[])))")])])]),e._v(" "),s("li",[s("p",[e._v("Functions on lists can be defined using "),s("code",[e._v("x:xs")]),e._v(" patterns")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("head :: [a] -> a\nhead (x:_) = x\ntail :: [a] -> [a]\ntail (_:xs) = xs\n")])])]),s("ul",[s("li",[s("code",[e._v("x:xs")]),e._v(" patterns only matches non-empty lists:")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("> head []\nERROR\n")])])]),s("h3",{attrs:{id:"lambda-expressions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambda-expressions"}},[e._v("#")]),e._v(" Lambda Expressions")]),e._v(" "),s("ul",[s("li",[e._v("Functions can be constructed without naming the functions by using lambda expressions")]),e._v(" "),s("li",[s("code",[e._v("\\x -> x+x")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("add x y = x + y\n")])])]),s("p",[e._v("means")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("add = \\x -> (\\y -> x+y)\n")])])]),s("ul",[s("li",[e._v("Lambda expressions are also useful when defining functions that return functions as results")])]),e._v(" "),s("p",[e._v("ex)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const :: a -> b -> a\nconst x _ = x\n")])])]),s("p",[e._v("to lambda")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const :: a -> ( b -> a )\nconst x = \\_ -> x\n")])])]),s("h3",{attrs:{id:"sections"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sections"}},[e._v("#")]),e._v(" Sections")]),e._v(" "),s("ul",[s("li",[e._v("An operator written before its arguments by using parentheses\nex)")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("> 1+ 2\n3\n> (+) 1 2\n3\n> (1+) 2\n3\n> (+2) 1\n3\n")])])]),s("ul",[s("li",[e._v("Useful functions can sometimes be constructed in a simple way using sections.")]),e._v(" "),s("li",[e._v("ex)")]),e._v(" "),s("li",[e._v("(1+) : successor function")]),e._v(" "),s("li",[e._v("(1/) : reciprocation function")]),e._v(" "),s("li",[e._v("(*2) : doubling function")]),e._v(" "),s("li",[e._v("(/2) : halving function")])])])}),[],!1,null,null,null);s.default=n.exports}}]);