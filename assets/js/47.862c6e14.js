(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{441:function(s,e,a){"use strict";a.r(e);var t=a(5),n=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"fp101x-week-4-list-comprehensions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fp101x-week-4-list-comprehensions"}},[s._v("#")]),s._v(" FP101x - week 4 List Comprehensions")]),s._v(" "),e("h3",{attrs:{id:"set-comprehensions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set-comprehensions"}},[s._v("#")]),s._v(" Set Comprehensions")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("the comprehension notation can be used to construct new sets from old sets")])]),s._v(" "),e("li",[e("p",[s._v("x <- [1..5] : generator")])]),s._v(" "),e("li",[e("p",[s._v("Comprehensions can have multiple generators , separated bu commas")])]),s._v(" "),e("li",[e("p",[s._v("ex)")])])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("> [(x,y) | x <- [1,2,3] , y <- [4,5]]\n[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]\n")])])]),e("ul",[e("li",[s._v("changing the order of the generators changes the order of the elements in the final list")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("> [(x,y) | y <- [4,5], x <- [1,2,3] ]\n[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]\n")])])]),e("h3",{attrs:{id:"dependant-generators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dependant-generators"}},[s._v("#")]),s._v(" dependant Generators")]),s._v(" "),e("ul",[e("li",[s._v("Later generators can depend on the variables\nex)")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("> [(x,y) | x <- [1..3], y <-[x..3]]\n[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]\n")])])]),e("ul",[e("li",[s._v("concatenates a list of lists")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("concat :: [[a]] -> [a]\nconcat xss = [x|xs <- xss, x <- xs]\n\n> concat [[1,2,3], [4,5], [6]]\n[1,2,3,4,5,6]\n")])])]),e("h3",{attrs:{id:"guards"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#guards"}},[s._v("#")]),s._v(" Guards")]),s._v(" "),e("ul",[e("li",[s._v("List comprehensions can use guards to restrict the values")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("> [ x | x <- [1..10], even x]\n[2,4,6,8,10]\n")])])]),e("ul",[e("li",[s._v("factors")]),s._v(" "),e("li",[s._v("maps a positive integer to its list of factors:")]),s._v(" "),e("li",[s._v("인자, 인수")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("factors :: Int -> [Int]\nfactors n = [ x | x <- [1..n], n ‘mod’ x == 0]\n\n> factor 15\n[1,3,5,15]\n")])])]),e("ul",[e("li",[s._v("prime")]),s._v(" "),e("li",[s._v("A positive integer is prime if its only factors are 1 and itself.")]),s._v(" "),e("li",[s._v("Hence, using factors we can define a function that decides it a number is prime")]),s._v(" "),e("li",[s._v("소수")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("prime :: Int -> Bool\nprime n = factors  == [1,n]\n\n> prime 15\nfalse\n> prime 7\ntruer\n")])])]),e("ul",[e("li",[s._v("primes")]),s._v(" "),e("li",[s._v("the list of all primes up to a given limit")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("primes :: Int -> [Int]\nprimes n = [x | x <- [2..n], prime x]\n\n> primes 40\n[2,3,5,7,11,13,17,19,23,29,31,37]\n")])])]),e("h3",{attrs:{id:"the-zip-function"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-zip-function"}},[s._v("#")]),s._v(" the Zip Function")]),s._v(" "),e("ul",[e("li",[s._v("maps two lists to a list of pairs of their corresponding elements")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("zip :: [a] -> [b] -> [(a,b)]\n\n> zip [‘a’,’b’,’c’] [1,2,3,4]\n[(‘a’,1),(‘b’,2),(‘c’,3)]\n")])])]),e("ul",[e("li",[s._v("pairs")]),s._v(" "),e("li",[s._v("Using zip we can define a function returns the list of all pairs of adjacent elements from a list")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("pairs :: [a] -> [(a,a)]\npairs xs = zip xs (tail xs)\n\n> pairs [1,2,3,4]\n[(1,2),(2,3),(3,4)]\n")])])]),e("ul",[e("li",[s._v("sorted")]),s._v(" "),e("li",[s._v("Using pairs we can define a function that decides if the elements in a list are sorted")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("sorted :: Ord a => [a] -> Bool\nsorted xs = and [ x <= y | (x,y) <- pairs xs ]\n\n> sorted [1,2,3,4]\nTrue\n> sorted [1,3,2,4]\nFalse\n")])])]),e("ul",[e("li",[s._v("positions")]),s._v(" "),e("li",[s._v("Using zip, functions that returns the list of all positions of a value in a list")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("positions :: Ez a => a -> [a] -> [Int]\npositions x xs =\n     [ i | (x’ ,i) <- zip xs [0..n], x == x’]\n      where n = length xs - 1\n\n> positions 0 [1,0,0,1,0,1,1,0]\n[1,2,4,7]\n")])])]),e("h3",{attrs:{id:"string-comprehensions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string-comprehensions"}},[s._v("#")]),s._v(" String Comprehensions")]),s._v(" "),e("ul",[e("li",[s._v("A string is a sequence of characters enclosed in double quotes")]),s._v(" "),e("li",[s._v("Strings are represented as lists of characters")]),s._v(" "),e("li",[s._v("“abc” :: String")]),s._v(" "),e("li",[s._v("means [‘a’,’b’,’c’] :: [Char]")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('> length “abcde"\n5\n\n>take 3 “abcde"\n“abc"\n\n> zip “abc” [1,2,3,4]\n[(‘a’,1),(‘b’,2),(‘c’,3)]\n')])])]),e("ul",[e("li",[s._v("lowers")]),s._v(" "),e("li",[s._v("function that counts the lower-case letters in a string")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('lowers :: String -> Int\nlowers xs = length [x | x <- xs, isLower x]\n\n> lowers “Haskell"\n6\n')])])])])}),[],!1,null,null,null);e.default=n.exports}}]);