(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{442:function(n,e,t){"use strict";t.r(e);var s=t(5),r=Object(s.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"fp101x-week-5-recursive-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fp101x-week-5-recursive-functions"}},[n._v("#")]),n._v(" FP101x - week 5 Recursive Functions")]),n._v(" "),e("ul",[e("li",[n._v("factorial :: Int -> Int")]),n._v(" "),e("li",[n._v("factorial n = product [1..n]")]),n._v(" "),e("li",[n._v("factorial maps any integer n to the product of the integers between 1 and n")]),n._v(" "),e("li",[n._v("ex)")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("factorial 4\n= product [1..4]\n= product [1,2,3,4]\n= 1*2*3*4\n```\n\n### Recursive Function\n- functions can also be defined in terms of themselves\n- factorial 0 = 1\n- factorial n = n * factorial (n-1)\n- ex)\n\n```\nfactorial 3\n= 3 * factorial 2\n= 3 * ( 2 * factorial 1)\n= 3 * ( 2 * ( 1 * factorial 0 ) )\n= 3 * ( 2 * ( 1 * 1 ) )\n= 3 * ( 2 * 1 )\n= 3 * 2\n= 6\n```\n\n### why\n- simpler to defined in terms of other functions.\n- naturally be defined in terms of themselves\n- simple but powerful mathematical technique of induction\n\n### Recursion of Lists\n- Recursion is not restricted to numbers, but can also be used to define functions on lists\n\n```\nproduct :: [Int] -> Int\nproduct [] = 1\nproduct (n:ns) = n * product ns\n```\n\n- product maps the empty list to 1 and any non-empty list to its head multiplied by the product of its tail\n\n```\nproduct [2,3,4]\n= 2 * product [3,4]\n= 2 * ( 3 * product [4])\n= 2 * ( 3 * ( 4 * product [] ) )\n= 2 * ( 3 * ( 4 * 1 ) )\n= 24\n```\n\nex ) function length\n\n```\nlength :: [a] -> Int\nlength [] = 0\nlength (_:xs) = 1 + length xs\n```\n\n```\nlength [ 1 , 2 , 3 ]\n= 1 + length [ 2 , 3 ]\n= 1 + ( 1 + length [ 3 ] )\n= 1 + ( 1 + ( 1 + length [ ] )\n= 1 + ( 1 + ( 1 + ( 1 + 0 ) )\n= 3\n```\n\nex ) reverse\n\n```\nreverse :: [a] -> [a]\nreverse [] = []\nreverse (x:xs) = reverse xs ++ [x]\n```\n\n```\nreverse [1,2,3]\n= reverse [2,3] ++ [1]\n= ( reverse [3] ++ [2] ) ++ [1]\n= ( (reverse [] ++ [3] ) ++ [2] ) ++ [1]\n= ( ([] ++ [3] ) ++ [2] ) ++ [1]\n= [3,2,1]\n```\n- appending the element from right to left\n\n### Multiple Arguments\n- zip\n\n```\nzip :: [a] -> [b] -> [(a,b)]\nzip [] _ = []\nzip _ [] = []\nzip (x:xs) (y:ys) = (x,y) : zip xs ys\n```\n\n- drop\n\n```\ndrop :: Int -> [a] -> [a]\ndrop 0 xs = xs\ndrop _ [] = []\ndrop n (_:xs) = drop (n-1) xs\n```\n\n- appending\n\n```\n(++) :: [a] -> [a] -> [a]\n[] ++ ys = ys\n(x:xs) ++ ys  = x : (xs ++ ys)\n```\n\n### Quicksort\n- rule 1 : The empty list is already sorted\n- rule 2 : Non-empty lists can be sorted by sorting the tail values <= the head sorting the tail values > the head, and then appending the resulting list on either side of the head value\n\n```\nqsort :: [Int] -> [Int]\nqsort [] = []\nqsort ( x : xs ) =\n     sort smaller ++ [x] ++ sort larger\n     where\n          smaller = [ a | a <- xs, x <= x]\n          larger = [ b | b <- xs, b > x ]\n```\n\n```\nq [ 3,2,4,1,5 ]\nq  [2,1] ++ [3] ++ q [4,5]\nq[1] ++ [2] ++ q[] ++ [3] ++ q[] ++ [4] ++ q[5]\n[1] ++ [2] ++ [] ++ [3] ++ [] ++ [4] ++ [5]\n```\n\n- produce a list with n identical elements\n\n```\nreplicate :: Int -> a -> [a]\n```\n\n- select the nth element of a list\n\n```\n(!!) :: [a] -> Int -> a\n```\n\n- decide if a value is an element of a list\n\n```\nelem :: Eq a => a -> [a] -> Bool\n```\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);